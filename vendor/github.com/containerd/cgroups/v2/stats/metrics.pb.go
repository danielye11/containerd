// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/containerd/cgroups/v2/stats/metrics.proto

package stats

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Metrics struct {
	Pids                 *PidsStat      `protobuf:"bytes,1,opt,name=pids,proto3" json:"pids,omitempty"`
	CPU                  *CPUStat       `protobuf:"bytes,2,opt,name=cpu,proto3" json:"cpu,omitempty"`
	Memory               *MemoryStat    `protobuf:"bytes,4,opt,name=memory,proto3" json:"memory,omitempty"`
	Rdma                 *RdmaStat      `protobuf:"bytes,5,opt,name=rdma,proto3" json:"rdma,omitempty"`
	Io                   *IOStat        `protobuf:"bytes,6,opt,name=io,proto3" json:"io,omitempty"`
	Hugetlb              []*HugeTlbStat `protobuf:"bytes,7,rep,name=hugetlb,proto3" json:"hugetlb,omitempty"`
	MemoryEvents         *MemoryEvents  `protobuf:"bytes,8,opt,name=memory_events,json=memoryEvents,proto3" json:"memory_events,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Metrics) Reset()      { *m = Metrics{} }
func (*Metrics) ProtoMessage() {}
func (*Metrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fc6005842049e6b, []int{0}
}
func (m *Metrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metrics.Merge(m, src)
}
func (m *Metrics) XXX_Size() int {
	return m.Size()
}
func (m *Metrics) XXX_DiscardUnknown() {
	xxx_messageInfo_Metrics.DiscardUnknown(m)
}

var xxx_messageInfo_Metrics proto.InternalMessageInfo

type PidsStat struct {
	Current              uint64   `protobuf:"varint,1,opt,name=current,proto3" json:"current,omitempty"`
	Limit                uint64   `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PidsStat) Reset()      { *m = PidsStat{} }
func (*PidsStat) ProtoMessage() {}
func (*PidsStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fc6005842049e6b, []int{1}
}
func (m *PidsStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PidsStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PidsStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PidsStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PidsStat.Merge(m, src)
}
func (m *PidsStat) XXX_Size() int {
	return m.Size()
}
func (m *PidsStat) XXX_DiscardUnknown() {
	xxx_messageInfo_PidsStat.DiscardUnknown(m)
}

var xxx_messageInfo_PidsStat proto.InternalMessageInfo

type CPUStat struct {
	UsageUsec            uint64   `protobuf:"varint,1,opt,name=usage_usec,json=usageUsec,proto3" json:"usage_usec,omitempty"`
	UserUsec             uint64   `protobuf:"varint,2,opt,name=user_usec,json=userUsec,proto3" json:"user_usec,omitempty"`
	SystemUsec           uint64   `protobuf:"varint,3,opt,name=system_usec,json=systemUsec,proto3" json:"system_usec,omitempty"`
	NrPeriods            uint64   `protobuf:"varint,4,opt,name=nr_periods,json=nrPeriods,proto3" json:"nr_periods,omitempty"`
	NrThrottled          uint64   `protobuf:"varint,5,opt,name=nr_throttled,json=nrThrottled,proto3" json:"nr_throttled,omitempty"`
	ThrottledUsec        uint64   `protobuf:"varint,6,opt,name=throttled_usec,json=throttledUsec,proto3" json:"throttled_usec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CPUStat) Reset()      { *m = CPUStat{} }
func (*CPUStat) ProtoMessage() {}
func (*CPUStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fc6005842049e6b, []int{2}
}
func (m *CPUStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPUStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPUStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPUStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPUStat.Merge(m, src)
}
func (m *CPUStat) XXX_Size() int {
	return m.Size()
}
func (m *CPUStat) XXX_DiscardUnknown() {
	xxx_messageInfo_CPUStat.DiscardUnknown(m)
}

var xxx_messageInfo_CPUStat proto.InternalMessageInfo

type MemoryStat struct {
	Anon                  uint64   `protobuf:"varint,1,opt,name=anon,proto3" json:"anon,omitempty"`
	File                  uint64   `protobuf:"varint,2,opt,name=file,proto3" json:"file,omitempty"`
	KernelStack           uint64   `protobuf:"varint,3,opt,name=kernel_stack,json=kernelStack,proto3" json:"kernel_stack,omitempty"`
	Slab                  uint64   `protobuf:"varint,4,opt,name=slab,proto3" json:"slab,omitempty"`
	Sock                  uint64   `protobuf:"varint,5,opt,name=sock,proto3" json:"sock,omitempty"`
	Shmem                 uint64   `protobuf:"varint,6,opt,name=shmem,proto3" json:"shmem,omitempty"`
	FileMapped            uint64   `protobuf:"varint,7,opt,name=file_mapped,json=fileMapped,proto3" json:"file_mapped,omitempty"`
	FileDirty             uint64   `protobuf:"varint,8,opt,name=file_dirty,json=fileDirty,proto3" json:"file_dirty,omitempty"`
	FileWriteback         uint64   `protobuf:"varint,9,opt,name=file_writeback,json=fileWriteback,proto3" json:"file_writeback,omitempty"`
	AnonThp               uint64   `protobuf:"varint,10,opt,name=anon_thp,json=anonThp,proto3" json:"anon_thp,omitempty"`
	InactiveAnon          uint64   `protobuf:"varint,11,opt,name=inactive_anon,json=inactiveAnon,proto3" json:"inactive_anon,omitempty"`
	ActiveAnon            uint64   `protobuf:"varint,12,opt,name=active_anon,json=activeAnon,proto3" json:"active_anon,omitempty"`
	InactiveFile          uint64   `protobuf:"varint,13,opt,name=inactive_file,json=inactiveFile,proto3" json:"inactive_file,omitempty"`
	ActiveFile            uint64   `protobuf:"varint,14,opt,name=active_file,json=activeFile,proto3" json:"active_file,omitempty"`
	Unevictable           uint64   `protobuf:"varint,15,opt,name=unevictable,proto3" json:"unevictable,omitempty"`
	SlabReclaimable       uint64   `protobuf:"varint,16,opt,name=slab_reclaimable,json=slabReclaimable,proto3" json:"slab_reclaimable,omitempty"`
	SlabUnreclaimable     uint64   `protobuf:"varint,17,opt,name=slab_unreclaimable,json=slabUnreclaimable,proto3" json:"slab_unreclaimable,omitempty"`
	Pgfault               uint64   `protobuf:"varint,18,opt,name=pgfault,proto3" json:"pgfault,omitempty"`
	Pgmajfault            uint64   `protobuf:"varint,19,opt,name=pgmajfault,proto3" json:"pgmajfault,omitempty"`
	WorkingsetRefault     uint64   `protobuf:"varint,20,opt,name=workingset_refault,json=workingsetRefault,proto3" json:"workingset_refault,omitempty"`
	WorkingsetActivate    uint64   `protobuf:"varint,21,opt,name=workingset_activate,json=workingsetActivate,proto3" json:"workingset_activate,omitempty"`
	WorkingsetNodereclaim uint64   `protobuf:"varint,22,opt,name=workingset_nodereclaim,json=workingsetNodereclaim,proto3" json:"workingset_nodereclaim,omitempty"`
	Pgrefill              uint64   `protobuf:"varint,23,opt,name=pgrefill,proto3" json:"pgrefill,omitempty"`
	Pgscan                uint64   `protobuf:"varint,24,opt,name=pgscan,proto3" json:"pgscan,omitempty"`
	Pgsteal               uint64   `protobuf:"varint,25,opt,name=pgsteal,proto3" json:"pgsteal,omitempty"`
	Pgactivate            uint64   `protobuf:"varint,26,opt,name=pgactivate,proto3" json:"pgactivate,omitempty"`
	Pgdeactivate          uint64   `protobuf:"varint,27,opt,name=pgdeactivate,proto3" json:"pgdeactivate,omitempty"`
	Pglazyfree            uint64   `protobuf:"varint,28,opt,name=pglazyfree,proto3" json:"pglazyfree,omitempty"`
	Pglazyfreed           uint64   `protobuf:"varint,29,opt,name=pglazyfreed,proto3" json:"pglazyfreed,omitempty"`
	ThpFaultAlloc         uint64   `protobuf:"varint,30,opt,name=thp_fault_alloc,json=thpFaultAlloc,proto3" json:"thp_fault_alloc,omitempty"`
	ThpCollapseAlloc      uint64   `protobuf:"varint,31,opt,name=thp_collapse_alloc,json=thpCollapseAlloc,proto3" json:"thp_collapse_alloc,omitempty"`
	Usage                 uint64   `protobuf:"varint,32,opt,name=usage,proto3" json:"usage,omitempty"`
	UsageLimit            uint64   `protobuf:"varint,33,opt,name=usage_limit,json=usageLimit,proto3" json:"usage_limit,omitempty"`
	SwapUsage             uint64   `protobuf:"varint,34,opt,name=swap_usage,json=swapUsage,proto3" json:"swap_usage,omitempty"`
	SwapLimit             uint64   `protobuf:"varint,35,opt,name=swap_limit,json=swapLimit,proto3" json:"swap_limit,omitempty"`
	Cache                 uint64   `protobuf:"varint,36,opt,name=cache,proto3" json:"cache,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *MemoryStat) Reset()      { *m = MemoryStat{} }
func (*MemoryStat) ProtoMessage() {}
func (*MemoryStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fc6005842049e6b, []int{3}
}
func (m *MemoryStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryStat.Merge(m, src)
}
func (m *MemoryStat) XXX_Size() int {
	return m.Size()
}
func (m *MemoryStat) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryStat.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryStat proto.InternalMessageInfo

type MemoryEvents struct {
	Low                  uint64   `protobuf:"varint,1,opt,name=low,proto3" json:"low,omitempty"`
	High                 uint64   `protobuf:"varint,2,opt,name=high,proto3" json:"high,omitempty"`
	Max                  uint64   `protobuf:"varint,3,opt,name=max,proto3" json:"max,omitempty"`
	Oom                  uint64   `protobuf:"varint,4,opt,name=oom,proto3" json:"oom,omitempty"`
	OomKill              uint64   `protobuf:"varint,5,opt,name=oom_kill,json=oomKill,proto3" json:"oom_kill,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemoryEvents) Reset()      { *m = MemoryEvents{} }
func (*MemoryEvents) ProtoMessage() {}
func (*MemoryEvents) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fc6005842049e6b, []int{4}
}
func (m *MemoryEvents) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryEvents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryEvents.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryEvents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryEvents.Merge(m, src)
}
func (m *MemoryEvents) XXX_Size() int {
	return m.Size()
}
func (m *MemoryEvents) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryEvents.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryEvents proto.InternalMessageInfo

type RdmaStat struct {
	Current              []*RdmaEntry `protobuf:"bytes,1,rep,name=current,proto3" json:"current,omitempty"`
	Limit                []*RdmaEntry `protobuf:"bytes,2,rep,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RdmaStat) Reset()      { *m = RdmaStat{} }
func (*RdmaStat) ProtoMessage() {}
func (*RdmaStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fc6005842049e6b, []int{5}
}
func (m *RdmaStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RdmaStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RdmaStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RdmaStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RdmaStat.Merge(m, src)
}
func (m *RdmaStat) XXX_Size() int {
	return m.Size()
}
func (m *RdmaStat) XXX_DiscardUnknown() {
	xxx_messageInfo_RdmaStat.DiscardUnknown(m)
}

var xxx_messageInfo_RdmaStat proto.InternalMessageInfo

type RdmaEntry struct {
	Device               string   `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	HcaHandles           uint32   `protobuf:"varint,2,opt,name=hca_handles,json=hcaHandles,proto3" json:"hca_handles,omitempty"`
	HcaObjects           uint32   `protobuf:"varint,3,opt,name=hca_objects,json=hcaObjects,proto3" json:"hca_objects,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RdmaEntry) Reset()      { *m = RdmaEntry{} }
func (*RdmaEntry) ProtoMessage() {}
func (*RdmaEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fc6005842049e6b, []int{6}
}
func (m *RdmaEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RdmaEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RdmaEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RdmaEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RdmaEntry.Merge(m, src)
}
func (m *RdmaEntry) XXX_Size() int {
	return m.Size()
}
func (m *RdmaEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_RdmaEntry.DiscardUnknown(m)
}

var xxx_messageInfo_RdmaEntry proto.InternalMessageInfo

type IOStat struct {
	Usage                []*IOEntry `protobuf:"bytes,1,rep,name=usage,proto3" json:"usage,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *IOStat) Reset()      { *m = IOStat{} }
func (*IOStat) ProtoMessage() {}
func (*IOStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fc6005842049e6b, []int{7}
}
func (m *IOStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IOStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IOStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IOStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IOStat.Merge(m, src)
}
func (m *IOStat) XXX_Size() int {
	return m.Size()
}
func (m *IOStat) XXX_DiscardUnknown() {
	xxx_messageInfo_IOStat.DiscardUnknown(m)
}

var xxx_messageInfo_IOStat proto.InternalMessageInfo

type IOEntry struct {
	Major                uint64   `protobuf:"varint,1,opt,name=major,proto3" json:"major,omitempty"`
	Minor                uint64   `protobuf:"varint,2,opt,name=minor,proto3" json:"minor,omitempty"`
	Rbytes               uint64   `protobuf:"varint,3,opt,name=rbytes,proto3" json:"rbytes,omitempty"`
	Wbytes               uint64   `protobuf:"varint,4,opt,name=wbytes,proto3" json:"wbytes,omitempty"`
	Rios                 uint64   `protobuf:"varint,5,opt,name=rios,proto3" json:"rios,omitempty"`
	Wios                 uint64   `protobuf:"varint,6,opt,name=wios,proto3" json:"wios,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IOEntry) Reset()      { *m = IOEntry{} }
func (*IOEntry) ProtoMessage() {}
func (*IOEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fc6005842049e6b, []int{8}
}
func (m *IOEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IOEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IOEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IOEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IOEntry.Merge(m, src)
}
func (m *IOEntry) XXX_Size() int {
	return m.Size()
}
func (m *IOEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_IOEntry.DiscardUnknown(m)
}

var xxx_messageInfo_IOEntry proto.InternalMessageInfo

type HugeTlbStat struct {
	Current              uint64   `protobuf:"varint,1,opt,name=current,proto3" json:"current,omitempty"`
	Max                  uint64   `protobuf:"varint,2,opt,name=max,proto3" json:"max,omitempty"`
	Pagesize             string   `protobuf:"bytes,3,opt,name=pagesize,proto3" json:"pagesize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HugeTlbStat) Reset()      { *m = HugeTlbStat{} }
func (*HugeTlbStat) ProtoMessage() {}
func (*HugeTlbStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_2fc6005842049e6b, []int{9}
}
func (m *HugeTlbStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HugeTlbStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HugeTlbStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HugeTlbStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HugeTlbStat.Merge(m, src)
}
func (m *HugeTlbStat) XXX_Size() int {
	return m.Size()
}
func (m *HugeTlbStat) XXX_DiscardUnknown() {
	xxx_messageInfo_HugeTlbStat.DiscardUnknown(m)
}

var xxx_messageInfo_HugeTlbStat proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Metrics)(nil), "io.containerd.cgroups.v2.Metrics")
	proto.RegisterType((*PidsStat)(nil), "io.containerd.cgroups.v2.PidsStat")
	proto.RegisterType((*CPUStat)(nil), "io.containerd.cgroups.v2.CPUStat")
	proto.RegisterType((*MemoryStat)(nil), "io.containerd.cgroups.v2.MemoryStat")
	proto.RegisterType((*MemoryEvents)(nil), "io.containerd.cgroups.v2.MemoryEvents")
	proto.RegisterType((*RdmaStat)(nil), "io.containerd.cgroups.v2.RdmaStat")
	proto.RegisterType((*RdmaEntry)(nil), "io.containerd.cgroups.v2.RdmaEntry")
	proto.RegisterType((*IOStat)(nil), "io.containerd.cgroups.v2.IOStat")
	proto.RegisterType((*IOEntry)(nil), "io.containerd.cgroups.v2.IOEntry")
	proto.RegisterType((*HugeTlbStat)(nil), "io.containerd.cgroups.v2.HugeTlbStat")
}

func init() {
	proto.RegisterFile("github.com/containerd/cgroups/v2/stats/metrics.proto", fileDescriptor_2fc6005842049e6b)
}

var fileDescriptor_2fc6005842049e6b = []byte{
	// 1209 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0xcd, 0x72, 0xdc, 0x44,
	0x10, 0xce, 0xda, 0x6b, 0xaf, 0x77, 0xd6, 0x4e, 0x9c, 0x89, 0x13, 0x94, 0x84, 0xac, 0xed, 0xcd,
	0x4f, 0x85, 0x2a, 0xd8, 0xa5, 0xcc, 0x5f, 0x41, 0x85, 0xa2, 0x9c, 0x90, 0x54, 0xa8, 0x10, 0xe2,
	0x52, 0xe2, 0xe2, 0xa8, 0x9a, 0x95, 0xc6, 0xd2, 0xc4, 0x92, 0x46, 0x35, 0x33, 0x6b, 0xe3, 0x9c,
	0x38, 0x70, 0xe5, 0x31, 0x78, 0x04, 0xde, 0x21, 0x37, 0x38, 0x72, 0xa2, 0x88, 0x9f, 0x84, 0xea,
	0xee, 0xd1, 0x4a, 0x1c, 0x9c, 0x70, 0x9b, 0xfe, 0xfa, 0xeb, 0x9e, 0xfe, 0x19, 0x75, 0x8b, 0x7d,
	0x9a, 0x2a, 0x97, 0xcd, 0xa6, 0xe3, 0x58, 0x17, 0x93, 0x58, 0x97, 0x4e, 0xa8, 0x52, 0x9a, 0x64,
	0x12, 0xa7, 0x46, 0xcf, 0x2a, 0x3b, 0x39, 0xda, 0x99, 0x58, 0x27, 0x9c, 0x9d, 0x14, 0xd2, 0x19,
	0x15, 0xdb, 0x71, 0x65, 0xb4, 0xd3, 0x3c, 0x50, 0x7a, 0xdc, 0xb0, 0xc7, 0x9e, 0x3d, 0x3e, 0xda,
	0xb9, 0xb6, 0x91, 0xea, 0x54, 0x23, 0x69, 0x02, 0x27, 0xe2, 0x8f, 0x7e, 0x5f, 0x64, 0xbd, 0xa7,
	0xe4, 0x81, 0x7f, 0xce, 0xba, 0x95, 0x4a, 0x6c, 0xd0, 0xd9, 0xea, 0xdc, 0x1d, 0xec, 0x8c, 0xc6,
	0x67, 0xb9, 0x1a, 0xef, 0xa9, 0xc4, 0x3e, 0x77, 0xc2, 0x85, 0xc8, 0xe7, 0xf7, 0xd8, 0x62, 0x5c,
	0xcd, 0x82, 0x05, 0x34, 0xdb, 0x3e, 0xdb, 0xec, 0xc1, 0xde, 0x3e, 0x58, 0xdd, 0xef, 0x9d, 0xfe,
	0xbd, 0xb9, 0xf8, 0x60, 0x6f, 0x3f, 0x04, 0x33, 0x7e, 0x8f, 0x2d, 0x17, 0xb2, 0xd0, 0xe6, 0x24,
	0xe8, 0xa2, 0x83, 0x5b, 0x67, 0x3b, 0x78, 0x8a, 0x3c, 0xbc, 0xd9, 0xdb, 0x40, 0xcc, 0x26, 0x29,
	0x44, 0xb0, 0xf4, 0xae, 0x98, 0xc3, 0xa4, 0x10, 0x14, 0x33, 0xf0, 0xf9, 0xc7, 0x6c, 0x41, 0xe9,
	0x60, 0x19, 0xad, 0xb6, 0xce, 0xb6, 0xfa, 0xee, 0x19, 0xda, 0x2c, 0x28, 0xcd, 0xbf, 0x61, 0xbd,
	0x6c, 0x96, 0x4a, 0x97, 0x4f, 0x83, 0xde, 0xd6, 0xe2, 0xdd, 0xc1, 0xce, 0xed, 0xb3, 0xcd, 0x1e,
	0xcf, 0x52, 0xf9, 0x22, 0x9f, 0xa2, 0x6d, 0x6d, 0xc5, 0x9f, 0xb0, 0x35, 0x0a, 0x3a, 0x92, 0x47,
	0xb2, 0x74, 0x36, 0x58, 0xc1, 0xdb, 0xef, 0xbc, 0x2b, 0xdf, 0x87, 0xc8, 0x0e, 0x57, 0x8b, 0x96,
	0x34, 0xfa, 0x8a, 0xad, 0xd4, 0x5d, 0xe0, 0x01, 0xeb, 0xc5, 0x33, 0x63, 0x64, 0xe9, 0xb0, 0x75,
	0xdd, 0xb0, 0x16, 0xf9, 0x06, 0x5b, 0xca, 0x55, 0xa1, 0x1c, 0xf6, 0xa6, 0x1b, 0x92, 0x30, 0xfa,
	0xa3, 0xc3, 0x7a, 0xbe, 0x17, 0xfc, 0x06, 0x63, 0x33, 0x2b, 0x52, 0x19, 0xcd, 0xac, 0x8c, 0xbd,
	0x79, 0x1f, 0x91, 0x7d, 0x2b, 0x63, 0x7e, 0x9d, 0xf5, 0x67, 0x56, 0x1a, 0xd2, 0x92, 0x93, 0x15,
	0x00, 0x50, 0xb9, 0xc9, 0x06, 0xf6, 0xc4, 0x3a, 0x59, 0x90, 0x7a, 0x11, 0xd5, 0x8c, 0x20, 0x24,
	0xdc, 0x60, 0xac, 0x34, 0x51, 0x25, 0x8d, 0xd2, 0x89, 0xc5, 0xf6, 0x76, 0xc3, 0x7e, 0x69, 0xf6,
	0x08, 0xe0, 0xdb, 0x6c, 0xb5, 0x34, 0x91, 0xcb, 0x8c, 0x76, 0x2e, 0x97, 0x09, 0xf6, 0xb0, 0x1b,
	0x0e, 0x4a, 0xf3, 0xa2, 0x86, 0xf8, 0x6d, 0x76, 0x7e, 0xae, 0xa7, 0x5b, 0x96, 0x91, 0xb4, 0x36,
	0x47, 0xe1, 0xa2, 0xd1, 0x6f, 0x7d, 0xc6, 0x9a, 0xc7, 0xc1, 0x39, 0xeb, 0x8a, 0x52, 0x97, 0x3e,
	0x1d, 0x3c, 0x03, 0x76, 0xa0, 0x72, 0xe9, 0x93, 0xc0, 0x33, 0x04, 0x70, 0x28, 0x4d, 0x29, 0xf3,
	0xc8, 0x3a, 0x11, 0x1f, 0xfa, 0x0c, 0x06, 0x84, 0x3d, 0x07, 0x08, 0xcc, 0x6c, 0x2e, 0xa6, 0x3e,
	0x78, 0x3c, 0x23, 0xa6, 0xe3, 0x43, 0x1f, 0x2f, 0x9e, 0xa1, 0xd2, 0x36, 0x2b, 0x64, 0xe1, 0xe3,
	0x23, 0x01, 0x2a, 0x04, 0x17, 0x45, 0x85, 0xa8, 0x2a, 0x99, 0x04, 0x3d, 0xaa, 0x10, 0x40, 0x4f,
	0x11, 0x81, 0x0a, 0x21, 0x21, 0x51, 0xc6, 0x9d, 0xe0, 0x83, 0xe8, 0x86, 0x7d, 0x40, 0xbe, 0x05,
	0x00, 0xd2, 0x47, 0xf5, 0xb1, 0x51, 0x4e, 0x4e, 0x21, 0xc4, 0x3e, 0xa5, 0x0f, 0xe8, 0x8f, 0x35,
	0xc8, 0xaf, 0xb2, 0x15, 0xc8, 0x31, 0x72, 0x59, 0x15, 0x30, 0x7a, 0x01, 0x20, 0xbf, 0xc8, 0x2a,
	0x7e, 0x93, 0xad, 0xa9, 0x52, 0xc4, 0x4e, 0x1d, 0xc9, 0x08, 0x6b, 0x32, 0x40, 0xfd, 0x6a, 0x0d,
	0xee, 0x42, 0x6d, 0x36, 0xd9, 0xa0, 0x4d, 0x59, 0xa5, 0x30, 0x5b, 0x84, 0xb6, 0x17, 0xac, 0xe2,
	0xda, 0x7f, 0xbd, 0x3c, 0x82, 0x6a, 0x36, 0x5e, 0x90, 0x72, 0xbe, 0xed, 0x05, 0x09, 0x5b, 0x6c,
	0x30, 0x2b, 0xe5, 0x91, 0x8a, 0x9d, 0x98, 0xe6, 0x32, 0xb8, 0x40, 0xd5, 0x6e, 0x41, 0xfc, 0x03,
	0xb6, 0x0e, 0x15, 0x8e, 0x8c, 0x8c, 0x73, 0xa1, 0x0a, 0xa4, 0xad, 0x23, 0xed, 0x02, 0xe0, 0x61,
	0x03, 0xf3, 0x8f, 0x18, 0x47, 0xea, 0xac, 0x6c, 0x93, 0x2f, 0x22, 0xf9, 0x22, 0x68, 0xf6, 0xdb,
	0x0a, 0xf8, 0x46, 0xaa, 0xf4, 0x40, 0xcc, 0x72, 0x17, 0x70, 0xaa, 0x90, 0x17, 0xf9, 0x90, 0xb1,
	0x2a, 0x2d, 0xc4, 0x4b, 0x52, 0x5e, 0xa2, 0xa8, 0x1b, 0x04, 0x2e, 0x3a, 0xd6, 0xe6, 0x50, 0x95,
	0xa9, 0x95, 0x2e, 0x32, 0x92, 0x78, 0x1b, 0x74, 0x51, 0xa3, 0x09, 0x49, 0xc1, 0x27, 0xec, 0x52,
	0x8b, 0x8e, 0xd9, 0x0b, 0x27, 0x83, 0xcb, 0xc8, 0x6f, 0x79, 0xda, 0xf5, 0x1a, 0xfe, 0x19, 0xbb,
	0xd2, 0x32, 0x28, 0x75, 0x22, 0x7d, 0xdc, 0xc1, 0x15, 0xb4, 0xb9, 0xdc, 0x68, 0x7f, 0x68, 0x94,
	0xfc, 0x1a, 0x5b, 0xa9, 0x52, 0x23, 0x0f, 0x54, 0x9e, 0x07, 0xef, 0xd1, 0x87, 0x59, 0xcb, 0xfc,
	0x0a, 0x5b, 0xae, 0x52, 0x1b, 0x8b, 0x32, 0x08, 0x50, 0xe3, 0x25, 0x2a, 0x82, 0x75, 0x52, 0xe4,
	0xc1, 0xd5, 0xba, 0x08, 0x28, 0x52, 0x11, 0xe6, 0xc1, 0x5e, 0xab, 0x8b, 0x50, 0x23, 0x7c, 0xc4,
	0x56, 0xab, 0x34, 0x91, 0x73, 0xc6, 0x75, 0xea, 0x7f, 0x1b, 0x23, 0x1f, 0xb9, 0x78, 0x75, 0x72,
	0x60, 0xa4, 0x0c, 0xde, 0xaf, 0x7d, 0xd4, 0x08, 0xb4, 0xbf, 0x91, 0x92, 0xe0, 0x06, 0xb5, 0xbf,
	0x05, 0xf1, 0x3b, 0xec, 0x82, 0xcb, 0xaa, 0x08, 0x0b, 0x19, 0x89, 0x3c, 0xd7, 0x71, 0x30, 0xac,
	0x3f, 0xf7, 0xea, 0x11, 0xa0, 0xbb, 0x00, 0xf2, 0x0f, 0x19, 0x07, 0x5e, 0xac, 0xf3, 0x5c, 0x54,
	0x56, 0x7a, 0xea, 0x26, 0x52, 0xd7, 0x5d, 0x56, 0x3d, 0xf0, 0x0a, 0x62, 0x6f, 0xb0, 0x25, 0x1c,
	0x68, 0xc1, 0x16, 0x7d, 0x9a, 0x28, 0xc0, 0x6b, 0xa5, 0xc1, 0x47, 0x03, 0x72, 0x9b, 0xc2, 0x45,
	0xe8, 0x7b, 0x40, 0xe0, 0xd3, 0xb4, 0xc7, 0xa2, 0x8a, 0xc8, 0x76, 0x44, 0x9f, 0x26, 0x20, 0xfb,
	0x68, 0x5f, 0xab, 0xc9, 0xfc, 0x66, 0xa3, 0x26, 0xeb, 0x0d, 0xb6, 0x14, 0x8b, 0x38, 0x93, 0xc1,
	0x2d, 0xba, 0x14, 0x85, 0x91, 0x65, 0xab, 0xed, 0x99, 0xce, 0xd7, 0xd9, 0x62, 0xae, 0x8f, 0xfd,
	0x9c, 0x82, 0x23, 0xcc, 0x96, 0x4c, 0xa5, 0x59, 0x3d, 0xa6, 0xe0, 0x0c, 0xac, 0x42, 0xfc, 0xe4,
	0xa7, 0x13, 0x1c, 0x01, 0xd1, 0xba, 0xf0, 0x43, 0x09, 0x8e, 0x30, 0x02, 0xb4, 0x2e, 0xa2, 0x43,
	0x78, 0x0e, 0x34, 0x97, 0x7a, 0x5a, 0x17, 0x4f, 0x54, 0x9e, 0x8f, 0x7e, 0xe9, 0xb0, 0x95, 0x7a,
	0xfb, 0xf1, 0xaf, 0xdb, 0xbb, 0x02, 0xb6, 0xd8, 0xcd, 0xb7, 0xaf, 0xcc, 0x87, 0xa5, 0x33, 0x27,
	0xcd, 0x42, 0xf9, 0xb2, 0x59, 0x28, 0xff, 0xdb, 0xd8, 0x6f, 0x1d, 0xc9, 0xfa, 0x73, 0x0c, 0x5e,
	0x68, 0x02, 0x9f, 0xbd, 0xc4, 0xdc, 0xfb, 0xa1, 0x97, 0xa0, 0x2b, 0x59, 0x2c, 0xa2, 0x4c, 0x94,
	0x49, 0x2e, 0x2d, 0x56, 0x61, 0x2d, 0x64, 0x59, 0x2c, 0x1e, 0x13, 0x52, 0x13, 0xf4, 0xf4, 0xa5,
	0x8c, 0x9d, 0xc5, 0x9a, 0x10, 0xe1, 0x19, 0x21, 0xa3, 0x5d, 0xb6, 0x4c, 0x4b, 0x9b, 0x7f, 0x51,
	0xf7, 0x9d, 0x12, 0xdd, 0x7e, 0xdb, 0x96, 0xf7, 0x91, 0x22, 0x7f, 0xf4, 0x6b, 0x87, 0xf5, 0x3c,
	0x04, 0x7d, 0x2c, 0xc4, 0x4b, 0x6d, 0x7c, 0x8f, 0x48, 0x40, 0x54, 0x95, 0xda, 0xd4, 0x7b, 0x15,
	0x05, 0x48, 0xca, 0x4c, 0x4f, 0x9c, 0xb4, 0xbe, 0x55, 0x5e, 0x02, 0xfc, 0x98, 0x70, 0x6a, 0x98,
	0x97, 0xa0, 0xd7, 0x46, 0x69, 0x5b, 0xef, 0x11, 0x38, 0x03, 0x76, 0x0c, 0x18, 0xad, 0x11, 0x3c,
	0x8f, 0xf6, 0xd9, 0xa0, 0xf5, 0x43, 0xf1, 0x96, 0x75, 0xef, 0x1f, 0xca, 0x42, 0xf3, 0x50, 0x60,
	0x4a, 0x88, 0x54, 0x5a, 0xf5, 0x4a, 0x62, 0x50, 0xfd, 0x70, 0x2e, 0xdf, 0x0f, 0x5e, 0xbf, 0x19,
	0x9e, 0xfb, 0xeb, 0xcd, 0xf0, 0xdc, 0xcf, 0xa7, 0xc3, 0xce, 0xeb, 0xd3, 0x61, 0xe7, 0xcf, 0xd3,
	0x61, 0xe7, 0x9f, 0xd3, 0x61, 0x67, 0xba, 0x8c, 0xff, 0x86, 0x9f, 0xfc, 0x1b, 0x00, 0x00, 0xff,
	0xff, 0x4a, 0xf9, 0x4d, 0x25, 0x83, 0x0a, 0x00, 0x00,
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MemoryEvents != nil {
		{
			size, err := m.MemoryEvents.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetrics(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Hugetlb) > 0 {
		for iNdEx := len(m.Hugetlb) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Hugetlb[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetrics(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Io != nil {
		{
			size, err := m.Io.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetrics(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Rdma != nil {
		{
			size, err := m.Rdma.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetrics(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Memory != nil {
		{
			size, err := m.Memory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetrics(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CPU != nil {
		{
			size, err := m.CPU.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetrics(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Pids != nil {
		{
			size, err := m.Pids.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetrics(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PidsStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PidsStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PidsStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.Current != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Current))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CPUStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPUStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPUStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ThrottledUsec != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.ThrottledUsec))
		i--
		dAtA[i] = 0x30
	}
	if m.NrThrottled != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.NrThrottled))
		i--
		dAtA[i] = 0x28
	}
	if m.NrPeriods != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.NrPeriods))
		i--
		dAtA[i] = 0x20
	}
	if m.SystemUsec != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.SystemUsec))
		i--
		dAtA[i] = 0x18
	}
	if m.UserUsec != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.UserUsec))
		i--
		dAtA[i] = 0x10
	}
	if m.UsageUsec != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.UsageUsec))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MemoryStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Cache != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Cache))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.SwapLimit != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.SwapLimit))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.SwapUsage != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.SwapUsage))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.UsageLimit != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.UsageLimit))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.Usage != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Usage))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.ThpCollapseAlloc != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.ThpCollapseAlloc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.ThpFaultAlloc != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.ThpFaultAlloc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.Pglazyfreed != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Pglazyfreed))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.Pglazyfree != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Pglazyfree))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.Pgdeactivate != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Pgdeactivate))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.Pgactivate != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Pgactivate))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.Pgsteal != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Pgsteal))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.Pgscan != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Pgscan))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.Pgrefill != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Pgrefill))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.WorkingsetNodereclaim != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.WorkingsetNodereclaim))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.WorkingsetActivate != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.WorkingsetActivate))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.WorkingsetRefault != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.WorkingsetRefault))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Pgmajfault != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Pgmajfault))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Pgfault != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Pgfault))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.SlabUnreclaimable != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.SlabUnreclaimable))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.SlabReclaimable != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.SlabReclaimable))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Unevictable != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Unevictable))
		i--
		dAtA[i] = 0x78
	}
	if m.ActiveFile != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.ActiveFile))
		i--
		dAtA[i] = 0x70
	}
	if m.InactiveFile != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InactiveFile))
		i--
		dAtA[i] = 0x68
	}
	if m.ActiveAnon != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.ActiveAnon))
		i--
		dAtA[i] = 0x60
	}
	if m.InactiveAnon != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InactiveAnon))
		i--
		dAtA[i] = 0x58
	}
	if m.AnonThp != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.AnonThp))
		i--
		dAtA[i] = 0x50
	}
	if m.FileWriteback != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.FileWriteback))
		i--
		dAtA[i] = 0x48
	}
	if m.FileDirty != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.FileDirty))
		i--
		dAtA[i] = 0x40
	}
	if m.FileMapped != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.FileMapped))
		i--
		dAtA[i] = 0x38
	}
	if m.Shmem != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Shmem))
		i--
		dAtA[i] = 0x30
	}
	if m.Sock != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Sock))
		i--
		dAtA[i] = 0x28
	}
	if m.Slab != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Slab))
		i--
		dAtA[i] = 0x20
	}
	if m.KernelStack != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.KernelStack))
		i--
		dAtA[i] = 0x18
	}
	if m.File != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.File))
		i--
		dAtA[i] = 0x10
	}
	if m.Anon != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Anon))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MemoryEvents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryEvents) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryEvents) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OomKill != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.OomKill))
		i--
		dAtA[i] = 0x28
	}
	if m.Oom != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Oom))
		i--
		dAtA[i] = 0x20
	}
	if m.Max != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Max))
		i--
		dAtA[i] = 0x18
	}
	if m.High != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.High))
		i--
		dAtA[i] = 0x10
	}
	if m.Low != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Low))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RdmaStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RdmaStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Limit) > 0 {
		for iNdEx := len(m.Limit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Limit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetrics(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Current) > 0 {
		for iNdEx := len(m.Current) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Current[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetrics(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RdmaEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RdmaEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RdmaEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HcaObjects != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.HcaObjects))
		i--
		dAtA[i] = 0x18
	}
	if m.HcaHandles != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.HcaHandles))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IOStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IOStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IOStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Usage) > 0 {
		for iNdEx := len(m.Usage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Usage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetrics(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IOEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IOEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IOEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Wios != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Wios))
		i--
		dAtA[i] = 0x30
	}
	if m.Rios != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Rios))
		i--
		dAtA[i] = 0x28
	}
	if m.Wbytes != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Wbytes))
		i--
		dAtA[i] = 0x20
	}
	if m.Rbytes != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Rbytes))
		i--
		dAtA[i] = 0x18
	}
	if m.Minor != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Minor))
		i--
		dAtA[i] = 0x10
	}
	if m.Major != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Major))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HugeTlbStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HugeTlbStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HugeTlbStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pagesize) > 0 {
		i -= len(m.Pagesize)
		copy(dAtA[i:], m.Pagesize)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Pagesize)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Max != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Max))
		i--
		dAtA[i] = 0x10
	}
	if m.Current != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Current))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMetrics(dAtA []byte, offset int, v uint64) int {
	offset -= sovMetrics(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pids != nil {
		l = m.Pids.Size()
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.CPU != nil {
		l = m.CPU.Size()
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.Rdma != nil {
		l = m.Rdma.Size()
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.Io != nil {
		l = m.Io.Size()
		n += 1 + l + sovMetrics(uint64(l))
	}
	if len(m.Hugetlb) > 0 {
		for _, e := range m.Hugetlb {
			l = e.Size()
			n += 1 + l + sovMetrics(uint64(l))
		}
	}
	if m.MemoryEvents != nil {
		l = m.MemoryEvents.Size()
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PidsStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Current != 0 {
		n += 1 + sovMetrics(uint64(m.Current))
	}
	if m.Limit != 0 {
		n += 1 + sovMetrics(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CPUStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UsageUsec != 0 {
		n += 1 + sovMetrics(uint64(m.UsageUsec))
	}
	if m.UserUsec != 0 {
		n += 1 + sovMetrics(uint64(m.UserUsec))
	}
	if m.SystemUsec != 0 {
		n += 1 + sovMetrics(uint64(m.SystemUsec))
	}
	if m.NrPeriods != 0 {
		n += 1 + sovMetrics(uint64(m.NrPeriods))
	}
	if m.NrThrottled != 0 {
		n += 1 + sovMetrics(uint64(m.NrThrottled))
	}
	if m.ThrottledUsec != 0 {
		n += 1 + sovMetrics(uint64(m.ThrottledUsec))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoryStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Anon != 0 {
		n += 1 + sovMetrics(uint64(m.Anon))
	}
	if m.File != 0 {
		n += 1 + sovMetrics(uint64(m.File))
	}
	if m.KernelStack != 0 {
		n += 1 + sovMetrics(uint64(m.KernelStack))
	}
	if m.Slab != 0 {
		n += 1 + sovMetrics(uint64(m.Slab))
	}
	if m.Sock != 0 {
		n += 1 + sovMetrics(uint64(m.Sock))
	}
	if m.Shmem != 0 {
		n += 1 + sovMetrics(uint64(m.Shmem))
	}
	if m.FileMapped != 0 {
		n += 1 + sovMetrics(uint64(m.FileMapped))
	}
	if m.FileDirty != 0 {
		n += 1 + sovMetrics(uint64(m.FileDirty))
	}
	if m.FileWriteback != 0 {
		n += 1 + sovMetrics(uint64(m.FileWriteback))
	}
	if m.AnonThp != 0 {
		n += 1 + sovMetrics(uint64(m.AnonThp))
	}
	if m.InactiveAnon != 0 {
		n += 1 + sovMetrics(uint64(m.InactiveAnon))
	}
	if m.ActiveAnon != 0 {
		n += 1 + sovMetrics(uint64(m.ActiveAnon))
	}
	if m.InactiveFile != 0 {
		n += 1 + sovMetrics(uint64(m.InactiveFile))
	}
	if m.ActiveFile != 0 {
		n += 1 + sovMetrics(uint64(m.ActiveFile))
	}
	if m.Unevictable != 0 {
		n += 1 + sovMetrics(uint64(m.Unevictable))
	}
	if m.SlabReclaimable != 0 {
		n += 2 + sovMetrics(uint64(m.SlabReclaimable))
	}
	if m.SlabUnreclaimable != 0 {
		n += 2 + sovMetrics(uint64(m.SlabUnreclaimable))
	}
	if m.Pgfault != 0 {
		n += 2 + sovMetrics(uint64(m.Pgfault))
	}
	if m.Pgmajfault != 0 {
		n += 2 + sovMetrics(uint64(m.Pgmajfault))
	}
	if m.WorkingsetRefault != 0 {
		n += 2 + sovMetrics(uint64(m.WorkingsetRefault))
	}
	if m.WorkingsetActivate != 0 {
		n += 2 + sovMetrics(uint64(m.WorkingsetActivate))
	}
	if m.WorkingsetNodereclaim != 0 {
		n += 2 + sovMetrics(uint64(m.WorkingsetNodereclaim))
	}
	if m.Pgrefill != 0 {
		n += 2 + sovMetrics(uint64(m.Pgrefill))
	}
	if m.Pgscan != 0 {
		n += 2 + sovMetrics(uint64(m.Pgscan))
	}
	if m.Pgsteal != 0 {
		n += 2 + sovMetrics(uint64(m.Pgsteal))
	}
	if m.Pgactivate != 0 {
		n += 2 + sovMetrics(uint64(m.Pgactivate))
	}
	if m.Pgdeactivate != 0 {
		n += 2 + sovMetrics(uint64(m.Pgdeactivate))
	}
	if m.Pglazyfree != 0 {
		n += 2 + sovMetrics(uint64(m.Pglazyfree))
	}
	if m.Pglazyfreed != 0 {
		n += 2 + sovMetrics(uint64(m.Pglazyfreed))
	}
	if m.ThpFaultAlloc != 0 {
		n += 2 + sovMetrics(uint64(m.ThpFaultAlloc))
	}
	if m.ThpCollapseAlloc != 0 {
		n += 2 + sovMetrics(uint64(m.ThpCollapseAlloc))
	}
	if m.Usage != 0 {
		n += 2 + sovMetrics(uint64(m.Usage))
	}
	if m.UsageLimit != 0 {
		n += 2 + sovMetrics(uint64(m.UsageLimit))
	}
	if m.SwapUsage != 0 {
		n += 2 + sovMetrics(uint64(m.SwapUsage))
	}
	if m.SwapLimit != 0 {
		n += 2 + sovMetrics(uint64(m.SwapLimit))
	}
	if m.Cache != 0 {
		n += 2 + sovMetrics(uint64(m.Cache))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoryEvents) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Low != 0 {
		n += 1 + sovMetrics(uint64(m.Low))
	}
	if m.High != 0 {
		n += 1 + sovMetrics(uint64(m.High))
	}
	if m.Max != 0 {
		n += 1 + sovMetrics(uint64(m.Max))
	}
	if m.Oom != 0 {
		n += 1 + sovMetrics(uint64(m.Oom))
	}
	if m.OomKill != 0 {
		n += 1 + sovMetrics(uint64(m.OomKill))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RdmaStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Current) > 0 {
		for _, e := range m.Current {
			l = e.Size()
			n += 1 + l + sovMetrics(uint64(l))
		}
	}
	if len(m.Limit) > 0 {
		for _, e := range m.Limit {
			l = e.Size()
			n += 1 + l + sovMetrics(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RdmaEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.HcaHandles != 0 {
		n += 1 + sovMetrics(uint64(m.HcaHandles))
	}
	if m.HcaObjects != 0 {
		n += 1 + sovMetrics(uint64(m.HcaObjects))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IOStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Usage) > 0 {
		for _, e := range m.Usage {
			l = e.Size()
			n += 1 + l + sovMetrics(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IOEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Major != 0 {
		n += 1 + sovMetrics(uint64(m.Major))
	}
	if m.Minor != 0 {
		n += 1 + sovMetrics(uint64(m.Minor))
	}
	if m.Rbytes != 0 {
		n += 1 + sovMetrics(uint64(m.Rbytes))
	}
	if m.Wbytes != 0 {
		n += 1 + sovMetrics(uint64(m.Wbytes))
	}
	if m.Rios != 0 {
		n += 1 + sovMetrics(uint64(m.Rios))
	}
	if m.Wios != 0 {
		n += 1 + sovMetrics(uint64(m.Wios))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HugeTlbStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Current != 0 {
		n += 1 + sovMetrics(uint64(m.Current))
	}
	if m.Max != 0 {
		n += 1 + sovMetrics(uint64(m.Max))
	}
	l = len(m.Pagesize)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMetrics(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetrics(x uint64) (n int) {
	return sovMetrics(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Metrics) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHugetlb := "[]*HugeTlbStat{"
	for _, f := range this.Hugetlb {
		repeatedStringForHugetlb += strings.Replace(f.String(), "HugeTlbStat", "HugeTlbStat", 1) + ","
	}
	repeatedStringForHugetlb += "}"
	s := strings.Join([]string{`&Metrics{`,
		`Pids:` + strings.Replace(this.Pids.String(), "PidsStat", "PidsStat", 1) + `,`,
		`CPU:` + strings.Replace(this.CPU.String(), "CPUStat", "CPUStat", 1) + `,`,
		`Memory:` + strings.Replace(this.Memory.String(), "MemoryStat", "MemoryStat", 1) + `,`,
		`Rdma:` + strings.Replace(this.Rdma.String(), "RdmaStat", "RdmaStat", 1) + `,`,
		`Io:` + strings.Replace(this.Io.String(), "IOStat", "IOStat", 1) + `,`,
		`Hugetlb:` + repeatedStringForHugetlb + `,`,
		`MemoryEvents:` + strings.Replace(this.MemoryEvents.String(), "MemoryEvents", "MemoryEvents", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PidsStat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PidsStat{`,
		`Current:` + fmt.Sprintf("%v", this.Current) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CPUStat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CPUStat{`,
		`UsageUsec:` + fmt.Sprintf("%v", this.UsageUsec) + `,`,
		`UserUsec:` + fmt.Sprintf("%v", this.UserUsec) + `,`,
		`SystemUsec:` + fmt.Sprintf("%v", this.SystemUsec) + `,`,
		`NrPeriods:` + fmt.Sprintf("%v", this.NrPeriods) + `,`,
		`NrThrottled:` + fmt.Sprintf("%v", this.NrThrottled) + `,`,
		`ThrottledUsec:` + fmt.Sprintf("%v", this.ThrottledUsec) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MemoryStat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MemoryStat{`,
		`Anon:` + fmt.Sprintf("%v", this.Anon) + `,`,
		`File:` + fmt.Sprintf("%v", this.File) + `,`,
		`KernelStack:` + fmt.Sprintf("%v", this.KernelStack) + `,`,
		`Slab:` + fmt.Sprintf("%v", this.Slab) + `,`,
		`Sock:` + fmt.Sprintf("%v", this.Sock) + `,`,
		`Shmem:` + fmt.Sprintf("%v", this.Shmem) + `,`,
		`FileMapped:` + fmt.Sprintf("%v", this.FileMapped) + `,`,
		`FileDirty:` + fmt.Sprintf("%v", this.FileDirty) + `,`,
		`FileWriteback:` + fmt.Sprintf("%v", this.FileWriteback) + `,`,
		`AnonThp:` + fmt.Sprintf("%v", this.AnonThp) + `,`,
		`InactiveAnon:` + fmt.Sprintf("%v", this.InactiveAnon) + `,`,
		`ActiveAnon:` + fmt.Sprintf("%v", this.ActiveAnon) + `,`,
		`InactiveFile:` + fmt.Sprintf("%v", this.InactiveFile) + `,`,
		`ActiveFile:` + fmt.Sprintf("%v", this.ActiveFile) + `,`,
		`Unevictable:` + fmt.Sprintf("%v", this.Unevictable) + `,`,
		`SlabReclaimable:` + fmt.Sprintf("%v", this.SlabReclaimable) + `,`,
		`SlabUnreclaimable:` + fmt.Sprintf("%v", this.SlabUnreclaimable) + `,`,
		`Pgfault:` + fmt.Sprintf("%v", this.Pgfault) + `,`,
		`Pgmajfault:` + fmt.Sprintf("%v", this.Pgmajfault) + `,`,
		`WorkingsetRefault:` + fmt.Sprintf("%v", this.WorkingsetRefault) + `,`,
		`WorkingsetActivate:` + fmt.Sprintf("%v", this.WorkingsetActivate) + `,`,
		`WorkingsetNodereclaim:` + fmt.Sprintf("%v", this.WorkingsetNodereclaim) + `,`,
		`Pgrefill:` + fmt.Sprintf("%v", this.Pgrefill) + `,`,
		`Pgscan:` + fmt.Sprintf("%v", this.Pgscan) + `,`,
		`Pgsteal:` + fmt.Sprintf("%v", this.Pgsteal) + `,`,
		`Pgactivate:` + fmt.Sprintf("%v", this.Pgactivate) + `,`,
		`Pgdeactivate:` + fmt.Sprintf("%v", this.Pgdeactivate) + `,`,
		`Pglazyfree:` + fmt.Sprintf("%v", this.Pglazyfree) + `,`,
		`Pglazyfreed:` + fmt.Sprintf("%v", this.Pglazyfreed) + `,`,
		`ThpFaultAlloc:` + fmt.Sprintf("%v", this.ThpFaultAlloc) + `,`,
		`ThpCollapseAlloc:` + fmt.Sprintf("%v", this.ThpCollapseAlloc) + `,`,
		`Usage:` + fmt.Sprintf("%v", this.Usage) + `,`,
		`UsageLimit:` + fmt.Sprintf("%v", this.UsageLimit) + `,`,
		`SwapUsage:` + fmt.Sprintf("%v", this.SwapUsage) + `,`,
		`SwapLimit:` + fmt.Sprintf("%v", this.SwapLimit) + `,`,
		`Cache:` + fmt.Sprintf("%v", this.Cache) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MemoryEvents) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MemoryEvents{`,
		`Low:` + fmt.Sprintf("%v", this.Low) + `,`,
		`High:` + fmt.Sprintf("%v", this.High) + `,`,
		`Max:` + fmt.Sprintf("%v", this.Max) + `,`,
		`Oom:` + fmt.Sprintf("%v", this.Oom) + `,`,
		`OomKill:` + fmt.Sprintf("%v", this.OomKill) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RdmaStat) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCurrent := "[]*RdmaEntry{"
	for _, f := range this.Current {
		repeatedStringForCurrent += strings.Replace(f.String(), "RdmaEntry", "RdmaEntry", 1) + ","
	}
	repeatedStringForCurrent += "}"
	repeatedStringForLimit := "[]*RdmaEntry{"
	for _, f := range this.Limit {
		repeatedStringForLimit += strings.Replace(f.String(), "RdmaEntry", "RdmaEntry", 1) + ","
	}
	repeatedStringForLimit += "}"
	s := strings.Join([]string{`&RdmaStat{`,
		`Current:` + repeatedStringForCurrent + `,`,
		`Limit:` + repeatedStringForLimit + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RdmaEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RdmaEntry{`,
		`Device:` + fmt.Sprintf("%v", this.Device) + `,`,
		`HcaHandles:` + fmt.Sprintf("%v", this.HcaHandles) + `,`,
		`HcaObjects:` + fmt.Sprintf("%v", this.HcaObjects) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IOStat) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUsage := "[]*IOEntry{"
	for _, f := range this.Usage {
		repeatedStringForUsage += strings.Replace(f.String(), "IOEntry", "IOEntry", 1) + ","
	}
	repeatedStringForUsage += "}"
	s := strings.Join([]string{`&IOStat{`,
		`Usage:` + repeatedStringForUsage + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IOEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IOEntry{`,
		`Major:` + fmt.Sprintf("%v", this.Major) + `,`,
		`Minor:` + fmt.Sprintf("%v", this.Minor) + `,`,
		`Rbytes:` + fmt.Sprintf("%v", this.Rbytes) + `,`,
		`Wbytes:` + fmt.Sprintf("%v", this.Wbytes) + `,`,
		`Rios:` + fmt.Sprintf("%v", this.Rios) + `,`,
		`Wios:` + fmt.Sprintf("%v", this.Wios) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HugeTlbStat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HugeTlbStat{`,
		`Current:` + fmt.Sprintf("%v", this.Current) + `,`,
		`Max:` + fmt.Sprintf("%v", this.Max) + `,`,
		`Pagesize:` + fmt.Sprintf("%v", this.Pagesize) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMetrics(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pids == nil {
				m.Pids = &PidsStat{}
			}
			if err := m.Pids.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPU", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CPU == nil {
				m.CPU = &CPUStat{}
			}
			if err := m.CPU.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &MemoryStat{}
			}
			if err := m.Memory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rdma", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rdma == nil {
				m.Rdma = &RdmaStat{}
			}
			if err := m.Rdma.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Io", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Io == nil {
				m.Io = &IOStat{}
			}
			if err := m.Io.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hugetlb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hugetlb = append(m.Hugetlb, &HugeTlbStat{})
			if err := m.Hugetlb[len(m.Hugetlb)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoryEvents == nil {
				m.MemoryEvents = &MemoryEvents{}
			}
			if err := m.MemoryEvents.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PidsStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PidsStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PidsStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			m.Current = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Current |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageUsec", wireType)
			}
			m.UsageUsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageUsec |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserUsec", wireType)
			}
			m.UserUsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserUsec |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemUsec", wireType)
			}
			m.SystemUsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SystemUsec |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NrPeriods", wireType)
			}
			m.NrPeriods = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NrPeriods |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NrThrottled", wireType)
			}
			m.NrThrottled = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NrThrottled |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThrottledUsec", wireType)
			}
			m.ThrottledUsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThrottledUsec |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anon", wireType)
			}
			m.Anon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Anon |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			m.File = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.File |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelStack", wireType)
			}
			m.KernelStack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KernelStack |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slab", wireType)
			}
			m.Slab = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slab |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sock", wireType)
			}
			m.Sock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shmem", wireType)
			}
			m.Shmem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shmem |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMapped", wireType)
			}
			m.FileMapped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileMapped |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileDirty", wireType)
			}
			m.FileDirty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileDirty |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileWriteback", wireType)
			}
			m.FileWriteback = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileWriteback |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnonThp", wireType)
			}
			m.AnonThp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnonThp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InactiveAnon", wireType)
			}
			m.InactiveAnon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InactiveAnon |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveAnon", wireType)
			}
			m.ActiveAnon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveAnon |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InactiveFile", wireType)
			}
			m.InactiveFile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InactiveFile |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveFile", wireType)
			}
			m.ActiveFile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveFile |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unevictable", wireType)
			}
			m.Unevictable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unevictable |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlabReclaimable", wireType)
			}
			m.SlabReclaimable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlabReclaimable |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlabUnreclaimable", wireType)
			}
			m.SlabUnreclaimable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlabUnreclaimable |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pgfault", wireType)
			}
			m.Pgfault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pgfault |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pgmajfault", wireType)
			}
			m.Pgmajfault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pgmajfault |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingsetRefault", wireType)
			}
			m.WorkingsetRefault = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkingsetRefault |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingsetActivate", wireType)
			}
			m.WorkingsetActivate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkingsetActivate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingsetNodereclaim", wireType)
			}
			m.WorkingsetNodereclaim = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkingsetNodereclaim |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pgrefill", wireType)
			}
			m.Pgrefill = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pgrefill |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pgscan", wireType)
			}
			m.Pgscan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pgscan |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pgsteal", wireType)
			}
			m.Pgsteal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pgsteal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pgactivate", wireType)
			}
			m.Pgactivate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pgactivate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pgdeactivate", wireType)
			}
			m.Pgdeactivate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pgdeactivate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pglazyfree", wireType)
			}
			m.Pglazyfree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pglazyfree |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pglazyfreed", wireType)
			}
			m.Pglazyfreed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pglazyfreed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThpFaultAlloc", wireType)
			}
			m.ThpFaultAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThpFaultAlloc |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThpCollapseAlloc", wireType)
			}
			m.ThpCollapseAlloc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThpCollapseAlloc |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			m.Usage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Usage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageLimit", wireType)
			}
			m.UsageLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapUsage", wireType)
			}
			m.SwapUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwapUsage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapLimit", wireType)
			}
			m.SwapLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwapLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cache", wireType)
			}
			m.Cache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cache |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryEvents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryEvents: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryEvents: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			m.Low = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Low |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			m.High = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.High |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			m.Max = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Max |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oom", wireType)
			}
			m.Oom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Oom |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OomKill", wireType)
			}
			m.OomKill = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OomKill |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Current = append(m.Current, &RdmaEntry{})
			if err := m.Current[len(m.Current)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Limit = append(m.Limit, &RdmaEntry{})
			if err := m.Limit[len(m.Limit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RdmaEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RdmaEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RdmaEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HcaHandles", wireType)
			}
			m.HcaHandles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HcaHandles |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HcaObjects", wireType)
			}
			m.HcaObjects = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HcaObjects |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IOStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IOStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IOStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usage = append(m.Usage, &IOEntry{})
			if err := m.Usage[len(m.Usage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IOEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IOEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IOEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			m.Major = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Major |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			m.Minor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rbytes", wireType)
			}
			m.Rbytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rbytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wbytes", wireType)
			}
			m.Wbytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wbytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rios", wireType)
			}
			m.Rios = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rios |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wios", wireType)
			}
			m.Wios = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wios |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HugeTlbStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HugeTlbStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HugeTlbStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			m.Current = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Current |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			m.Max = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Max |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagesize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pagesize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetrics(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetrics
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMetrics
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMetrics
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMetrics        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetrics          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMetrics = fmt.Errorf("proto: unexpected end of group")
)
